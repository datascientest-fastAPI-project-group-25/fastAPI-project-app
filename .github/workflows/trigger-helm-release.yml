name: Reusable Release Trigger

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string
        description: "Version to use for the release (with optional environment suffix)"
      environment:
        required: true
        type: string
        description: "Environment (stg or prod)"
      backend_image:
        required: true
        type: string
        description: "Full backend image reference including registry and tag"
      frontend_image:
        required: true
        type: string
        description: "Full frontend image reference including registry and tag"
      semantic_version:
        required: false
        type: string
        description: "Semantic version (without environment suffix) for use in Helm charts"
    secrets:
      MACHINE_USER_TOKEN:
        required: true
        description: "Token with permissions to trigger workflows in the release repo"

permissions:
  contents: write

jobs:
  trigger-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Debug inputs
        run: |
          echo "Input version: '${{ inputs.version }}'"
          echo "Input environment: '${{ inputs.environment }}'"
          echo "Input semantic_version: '${{ inputs.semantic_version }}'"
          echo "Input backend_image: '${{ inputs.backend_image }}'"
          echo "Input frontend_image: '${{ inputs.frontend_image }}'"

      - name: Heal or validate semantic version for production
        id: heal_version
        run: |
          VERSION_INPUT="${{ inputs.version }}"
          ENVIRONMENT="${{ inputs.environment }}"
          SEMANTIC_VERSION="${{ inputs.semantic_version }}"
          SEMVER_REGEX='^[0-9]+\.[0-9]+\.[0-9]+$'

          # First check if semantic_version is provided and valid
          if [[ -n "$SEMANTIC_VERSION" && "$SEMANTIC_VERSION" =~ $SEMVER_REGEX ]]; then
            echo "Using provided semantic version: $SEMANTIC_VERSION"
            VERSION_INPUT="$SEMANTIC_VERSION"
          elif [[ "$ENVIRONMENT" == "prod" ]]; then
            # For production, we need a valid semantic version
            if [[ ! "$VERSION_INPUT" =~ $SEMVER_REGEX ]]; then
              echo "Input version '$VERSION_INPUT' is not a valid semantic version. Attempting to heal..."

              # Try to read from VERSION file if present
              if [ -f VERSION ]; then
                echo "VERSION file exists, trying to read from it"
                cat VERSION
                VERSION_FILE=$(cat VERSION | grep -Eo "$SEMVER_REGEX" | head -n1)
                if [[ "$VERSION_FILE" =~ $SEMVER_REGEX ]]; then
                  echo "Healed version from VERSION file: $VERSION_FILE"
                  VERSION_INPUT="$VERSION_FILE"
                else
                  echo "Could not extract valid version from VERSION file"
                fi
              else
                echo "VERSION file not found"
              fi

              # Try to extract a semver from the input string
              if [[ ! "$VERSION_INPUT" =~ $SEMVER_REGEX ]]; then
                EXTRACTED=$(echo "$VERSION_INPUT" | grep -Eo "$SEMVER_REGEX" | head -n1)
                if [[ "$EXTRACTED" =~ $SEMVER_REGEX ]]; then
                  echo "Healed version by extracting from input: $EXTRACTED"
                  VERSION_INPUT="$EXTRACTED"
                fi
              fi

              # If still invalid, try to get the current version from version.py
              if [[ ! "$VERSION_INPUT" =~ $SEMVER_REGEX ]] && [ -f "version.py" ]; then
                echo "Trying to get version from version.py"
                if python version.py get 2>/dev/null; then
                  VERSION_PY=$(python version.py get)
                  if [[ "$VERSION_PY" =~ $SEMVER_REGEX ]]; then
                    echo "Healed version from version.py: $VERSION_PY"
                    VERSION_INPUT="$VERSION_PY"
                  fi
                fi
              fi

              # If still invalid, fail
              if [[ ! "$VERSION_INPUT" =~ $SEMVER_REGEX ]]; then
                echo "::error::Production releases must use a valid semantic version (e.g., 1.2.3). Healing failed."
                exit 1
              fi
            fi
          fi

          echo "Final version to be used: $VERSION_INPUT"
          echo "version=$VERSION_INPUT" >> $GITHUB_OUTPUT
      - name: Prepare payload for release repository
        id: prepare_payload
        run: |
          # The version after healing/validation
          VERSION="${{ steps.heal_version.outputs.version }}"
          # Environment (stg or prod)
          ENVIRONMENT="${{ inputs.environment }}"
          # Regular expression for semantic versioning (X.Y.Z)
          SEMVER_REGEX='^[0-9]+\.[0-9]+\.[0-9]+$'

          echo "\nðŸ“¦ Preparing payload for release repository"
          echo "- Healed version: $VERSION"
          echo "- Environment: $ENVIRONMENT"
          echo "- Input semantic_version: ${{ inputs.semantic_version }}"

          # STEP 1: Determine the semantic version (X.Y.Z format without environment suffix)
          # This is critical for proper versioning in Helm charts

          # First check if inputs.semantic_version is provided and valid
          if [[ -n "${{ inputs.semantic_version }}" && "${{ inputs.semantic_version }}" =~ $SEMVER_REGEX ]]; then
            SEMVER="${{ inputs.semantic_version }}"
            echo "âœ… Using provided semantic version: $SEMVER"
          # Try to extract from VERSION if it contains a semantic version
          elif [[ "$VERSION" =~ $SEMVER_REGEX ]]; then
            SEMVER="${BASH_REMATCH[0]}"
            echo "âœ… Extracted semantic version from VERSION: $SEMVER"
          # For staging, try to read from VERSION file
          elif [[ "$ENVIRONMENT" == "stg" ]]; then
            # Try to read from VERSION file
            if [ -f VERSION ]; then
              VERSION_FILE=$(cat VERSION | grep -Eo "$SEMVER_REGEX" | head -n1)
              if [[ "$VERSION_FILE" =~ $SEMVER_REGEX ]]; then
                SEMVER="$VERSION_FILE"
                echo "âœ… Using version from VERSION file for staging: $SEMVER"
              else
                echo "::error::Invalid version format in VERSION file. Expected format: X.Y.Z"
                echo "::error::Content of VERSION file: $(cat VERSION)"
                echo "::error::Please ensure the VERSION file contains a valid semantic version."
                exit 1
              fi
            else
              echo "::error::VERSION file not found. This file is required for determining the semantic version."
              echo "::error::Please create a VERSION file with a valid semantic version (e.g., 0.1.0)."
              exit 1
            fi
          # For production, we should already have a valid semver from heal_version
          else
            SEMVER="$VERSION"
            echo "âœ… Using VERSION as semantic version: $SEMVER"

            # Final check to ensure it's valid
            if [[ ! "$SEMVER" =~ $SEMVER_REGEX ]]; then
              echo "::error::No valid semantic version found for production release."
              echo "::error::Received version: '$VERSION'"
              echo "::error::Received semantic_version: '${{ inputs.semantic_version }}'"
              echo "::error::Please ensure a valid semantic version is provided."
              exit 1
            fi
          fi

          # STEP 2: Process the version based on environment
          # For staging: Use stg-HASH format for Docker image tags
          # For production: Use semantic version directly
          if [[ "$ENVIRONMENT" == "stg" ]]; then
            # Extract git hash from the version (assuming format stg-HASH)
            GIT_HASH=$(echo "${{ inputs.version }}" | grep -o '[a-f0-9]\{7,40\}' || echo '')

            if [[ -n "$GIT_HASH" ]]; then
              # Use first 7 characters of git hash
              SHORT_HASH="${GIT_HASH:0:7}"
              # Create a version that includes just the hash for the image tag
              # IMPORTANT: This format must be maintained exactly as "stg-{hash}"
              # The release repository expects this exact format for staging images
              MODIFIED_VERSION="stg-$SHORT_HASH"
              echo "âœ… Modified version for staging image tag: $MODIFIED_VERSION"
              echo "version=$MODIFIED_VERSION" >> $GITHUB_OUTPUT

              # For semantic version, append -stg to the semver
              # This is used for Helm chart versioning in staging
              SEMVER="${SEMVER}-stg"
              echo "âœ… Modified semantic version for staging: $SEMVER"
            else
              echo "âš ï¸ No git hash found in version, using original version: $VERSION"
              echo "version=$VERSION" >> $GITHUB_OUTPUT
            fi
          else
            # For production, use the semantic version directly
            echo "âœ… Using original version for production: $VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          fi

          # Output the semantic version for use in the release repository
          echo "semantic_version=$SEMVER" >> $GITHUB_OUTPUT

          # Also output the clean semantic version (without -stg suffix)
          # This is important for the release repository to handle version comparisons correctly
          if [[ "$SEMVER" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-stg$ ]]; then
            CLEAN_SEMVER="${BASH_REMATCH[1]}"
            echo "clean_semver=$CLEAN_SEMVER" >> $GITHUB_OUTPUT
          else
            echo "clean_semver=$SEMVER" >> $GITHUB_OUTPUT
          fi

          echo "\nâœ… Final payload values:"
          echo "- version: $VERSION"
          echo "- environment: $ENVIRONMENT"
          echo "- semantic_version: $SEMVER"
          echo "- clean_semver: $(cat $GITHUB_OUTPUT | grep clean_semver= | cut -d= -f2)"

      - name: Trigger Release Repository Workflow
        uses: peter-evans/repository-dispatch@v2
        env:
          GH_TOKEN: ${{ secrets.MACHINE_USER_TOKEN }}
        with:
          token: ${{ secrets.MACHINE_USER_TOKEN }}
          repository: datascientest-fastapi-project-group-25/fastAPI-project-release
          event-type: app-release
          client-payload: |
            {
              "version": "${{ steps.prepare_payload.outputs.version }}",
              "environment": "${{ inputs.environment }}",
              "backend_image": "${{ inputs.backend_image }}",
              "frontend_image": "${{ inputs.frontend_image }}",
              "semantic_version": "${{ steps.prepare_payload.outputs.semantic_version }}",
              "clean_semver": "${{ steps.prepare_payload.outputs.clean_semver }}"
            }
